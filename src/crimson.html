<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Crimson – Générateur de palettes & tokens</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
        tailwind.config = { darkMode: 'class' };
    </script>
    <style>
        body { font-family: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
        .smooth { transition: all .2s ease; }
        .chip { font-size: 10px; padding: 2px 6px; border-radius: 9999px; }
    </style>
    <!-- Style dynamique injecté par JS pour les variables CSS -->
    <style id="crimson-theme"></style>
</head>
<body class="bg-[var(--color-bg)] text-[var(--color-text)] transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useRef } = React;

        // --------------------- Utils Couleur & Tokens ---------------------
        const clamp = (n, min, max) => Math.min(max, Math.max(min, n));
        const sanitizeHex = (hex) => {
            if (!hex) return '#000000';
            let h = hex.trim().toLowerCase();
            if (!h.startsWith('#')) h = '#' + h;
            if (h.length === 4) { h = '#' + h[1]+h[1]+h[2]+h[2]+h[3]+h[3]; }
            return /^#([0-9a-f]{6})$/.test(h) ? h : '#000000';
        };

        const Color = {
            hexToHsl(hex) {
                hex = sanitizeHex(hex);
                const r = parseInt(hex.slice(1,3),16)/255;
                const g = parseInt(hex.slice(3,5),16)/255;
                const b = parseInt(hex.slice(5,7),16)/255;
                const max = Math.max(r,g,b), min = Math.min(r,g,b);
                let h, s; let l = (max+min)/2;
                if (max === min) { h = s = 0; }
                else {
                    const d = max - min;
                    s = l > .5 ? d/(2-max-min) : d/(max+min);
                    switch(max){
                        case r: h = (g-b)/d + (g<b?6:0); break;
                        case g: h = (b-r)/d + 2; break;
                        case b: h = (r-g)/d + 4; break;
                    }
                    h /= 6;
                }
                return [Math.round(h*360), Math.round(s*100), Math.round(l*100)];
            },
            hslToHex(h,s,l){
                h = ((h%360)+360)%360; s/=100; l/=100;
                const c = (1-Math.abs(2*l-1))*s;
                const x = c*(1-Math.abs((h/60)%2-1));
                const m = l - c/2; let r,g,b;
                if (h<60) [r,g,b] = [c,x,0];
                else if (h<120) [r,g,b]=[x,c,0];
                else if (h<180) [r,g,b]=[0,c,x];
                else if (h<240) [r,g,b]=[0,x,c];
                else if (h<300) [r,g,b]=[x,0,c];
                else [r,g,b]=[c,0,x];
                const toHex = v => {
                    const hv = Math.round((v+m)*255).toString(16).padStart(2,'0');
                    return hv;
                }
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`;
            },
            lighten(hex, amount){
                const [h,s,l]=this.hexToHsl(hex); return this.hslToHex(h,s,clamp(l+amount,0,100));
            },
            saturate(hex, amount){
                const [h,s,l]=this.hexToHsl(hex); return this.hslToHex(h,clamp(s+amount,0,100),l);
            },
            rotate(hex, deg){
                const [h,s,l]=this.hexToHsl(hex); return this.hslToHex(h+deg,s,l);
            },
            contrastRatio(hex1, hex2){
                const rl = (h) => {
                    h = sanitizeHex(h);
                    const c = [1,3,5].map(i=>parseInt(h.slice(i,i+2),16)/255).map(v=> v<=0.03928? v/12.92 : Math.pow((v+0.055)/1.055,2.4));
                    return 0.2126*c[0] + 0.7152*c[1] + 0.0722*c[2];
                };
                const L1 = rl(hex1), L2 = rl(hex2);
                const brightest = Math.max(L1,L2), darkest = Math.min(L1,L2);
                return (brightest+0.05)/(darkest+0.05);
            },
            bestTextOn(bg){
                return this.contrastRatio(bg,'#000000') >= 4.5 ? '#000000' : '#ffffff';
            }
        };

        const Harmonies = {
            build(base, mode){
                base = sanitizeHex(base);
                const [h,s,l]=Color.hexToHsl(base);
                const mk = (hh, ss=s, ll=l)=> Color.hslToHex(hh, clamp(ss,0,100), clamp(ll,0,100));
                const schemes = {
                    complementary: {
                        primary: base,
                        secondary: mk(h+180),
                        accent: mk(h+30, s, l),
                        neutral: mk(h, 8, 50)
                    },
                    analogous: {
                        primary: base,
                        secondary: mk(h-30, s, l),
                        accent: mk(h+30, s, l),
                        neutral: mk(h, 8, 50)
                    },
                    triadic: {
                        primary: base,
                        secondary: mk(h+120, s, l),
                        accent: mk(h+240, s, l),
                        neutral: mk(h, 8, 50)
                    },
                    monochrome: {
                        primary: base,
                        secondary: mk(h, clamp(s-20,0,100), clamp(l+10,0,100)),
                        accent: mk(h, clamp(s+15,0,100), clamp(l-10,0,100)),
                        neutral: mk(h, 6, 50)
                    }
                };
                return schemes[mode] || schemes.complementary;
            }
        };

        // Transforme des couleurs de base en tokens UI (light/dark)
        function buildTokensFromBase(baseSet){
            const mkSemantic = (hex, isDark=false) => {
                const base = sanitizeHex(hex);
                const hover = isDark ? Color.lighten(base, 8) : Color.lighten(base, -6);
                const active = isDark ? Color.lighten(base, -6) : Color.lighten(base, -12);
                const border = Color.lighten(base, isDark? -20 : -20);
                const text = Color.bestTextOn(base);
                return { base, hover, active, border, text };
            };

            const light = {
                background: '#ffffff',
                surface: '#ffffff',
                overlay: 'rgba(0,0,0,0.5)',
                border: '#e5e7eb',
                focus: '#3b82f6',
                text: { primary: '#111827', secondary: '#374151', inverse: '#ffffff' },
                colors: {
                    primary: mkSemantic(baseSet.primary, false),
                    secondary: mkSemantic(baseSet.secondary, false),
                    accent: mkSemantic(baseSet.accent, false),
                    success: mkSemantic('#10b981', false),
                    warning: mkSemantic('#f59e0b', false),
                    danger: mkSemantic('#ef4444', false),
                    info: mkSemantic('#3b82f6', false),
                    neutral: mkSemantic(baseSet.neutral, false)
                }
            };

            const dark = {
                background: '#0b1220',
                surface: '#111827',
                overlay: 'rgba(0,0,0,0.6)',
                border: '#374151',
                focus: '#60a5fa',
                text: { primary: '#f9fafb', secondary: '#d1d5db', inverse: '#111827' },
                colors: {
                    primary: mkSemantic(baseSet.primary, true),
                    secondary: mkSemantic(baseSet.secondary, true),
                    accent: mkSemantic(baseSet.accent, true),
                    success: mkSemantic('#10b981', true),
                    warning: mkSemantic('#f59e0b', true),
                    danger: mkSemantic('#ef4444', true),
                    info: mkSemantic('#60a5fa', true),
                    neutral: mkSemantic(baseSet.neutral, true)
                }
            };
            return { light, dark };
        }

        function tokensToCSSVars(tokens){
            const asVars = (t) => {
                const lines = [];
                lines.push(`--color-bg: ${t.background};`);
                lines.push(`--color-surface: ${t.surface};`);
                lines.push(`--color-overlay: ${t.overlay};`);
                lines.push(`--color-border: ${t.border};`);
                lines.push(`--color-focus: ${t.focus};`);
                lines.push(`--color-text: ${t.text.primary};`);
                lines.push(`--color-text-muted: ${t.text.secondary};`);
                lines.push(`--color-text-inverse: ${t.text.inverse};`);
                const addSet = (name, o) => {
                    lines.push(`--color-${name}: ${o.base};`);
                    lines.push(`--color-${name}-hover: ${o.hover};`);
                    lines.push(`--color-${name}-active: ${o.active};`);
                    lines.push(`--color-${name}-border: ${o.border};`);
                    lines.push(`--color-${name}-text: ${o.text};`);
                };
                Object.entries(t.colors).forEach(([k,v])=>addSet(k,v));
                return lines.join('\n  ');
            };
            return `:root{\n  ${asVars(tokens.light)}\n}\n.dark{\n  ${asVars(tokens.dark)}\n}`;
        }

        // --------------------------- App ---------------------------
        function CrimsonApp(){
            const [darkMode, setDarkMode] = useState(false);
            const [activeTab, setActiveTab] = useState('generator');
            const [mode, setMode] = useState('complementary');
            const [baseColor, setBaseColor] = useState('#dc2626');
            const [tokens, setTokens] = useState(()=> buildTokensFromBase(Harmonies.build('#dc2626','complementary')));
            const [locks, setLocks] = useState(new Set()); // keys: `${theme}|path` ex: "light|colors.primary.base"
            const [editingTheme, setEditingTheme] = useState('light');
            const fileInputRef = useRef(null);

            // Appliquer dark class
            useEffect(()=>{
                document.documentElement.classList.toggle('dark', darkMode);
            },[darkMode]);

            // Appliquer les variables CSS
            useEffect(()=>{
                const style = document.getElementById('crimson-theme');
                style.textContent = tokensToCSSVars(tokens);
            },[tokens]);

            // Générer à partir d'un set de base, en respectant les locks
            const regenerate = () => {
                const baseSet = Harmonies.build(baseColor, mode);
                const fresh = buildTokensFromBase(baseSet);
                const merged = structuredClone(tokens);
                const applyIfNotLocked = (theme, path, value) => {
                    const key = `${theme}|${path}`;
                    if (!locks.has(key)) setPath(merged[theme], path, value);
                };
                // Parcourir fresh et appliquer
                iterateTokens(fresh, (theme, path, value)=> applyIfNotLocked(theme, path, value));
                setTokens(merged);
            };

            // Helpers pour lecture/écriture dans l'objet de tokens
            const setPath = (obj, path, value) => {
                const parts = path.split('.');
                let cur = obj;
                for (let i=0;i<parts.length-1;i++) cur = cur[parts[i]];
                cur[parts.at(-1)] = value;
            };
            const getPath = (obj, path) => path.split('.').reduce((o,k)=>o?.[k], obj);

            const iterateTokens = (tks, cb) => {
                const walk = (themeName, base, prefix=[]) => {
                    for (const [k,v] of Object.entries(base)){
                        const p = [...prefix,k];
                        if (typeof v === 'object' && v && !('base' in v && 'hover' in v && 'active' in v && 'border' in v && 'text' in v)) {
                            walk(themeName, v, p);
                        } else if (typeof v === 'string') {
                            cb(themeName, p.join('.'), v);
                        } else if (typeof v === 'object') {
                            for (const [sk, sv] of Object.entries(v)) cb(themeName, [...p, sk].join('.'), sv);
                        }
                    }
                };
                walk('light', tks.light, []);
                walk('dark', tks.dark, []);
            };

            // Edition d'un token
            const updateToken = (theme, path, value) => {
                value = sanitizeHex(value);
                setTokens(prev => {
                    const next = structuredClone(prev);
                    setPath(next[theme], path, value);
                    return next;
                });
            };

            const toggleLock = (theme, path) => {
                const key = `${theme}|${path}`;
                setLocks(prev => {
                    const next = new Set(prev);
                    if (next.has(key)) next.delete(key); else next.add(key);
                    return next;
                });
            };

            // Exports
            const doExport = (format) => {
                let data = '';
                if (format==='css') data = tokensToCSSVars(tokens);
                if (format==='scss') data = tokensToScss(tokens);
                if (format==='json') data = JSON.stringify(tokens, null, 2);
                if (format==='tailwind') data = tokensToTailwind(tokens);
                if (format==='xaml') data = tokensToXaml(tokens);
                const blob = new Blob([data], { type: 'text/plain' });
                const url = URL.createObjectURL(blob); const a = document.createElement('a');
                a.href = url; a.download = `crimson-tokens.${format==='json'?'json': format==='xaml'?'xaml':'txt'}`; a.click();
                URL.revokeObjectURL(url);
            };

            const tokensToScss = (t) => {
                const esc = (s)=> s.replace(/\./g,'-');
                const lines = [];
                const build = (themeName, obj, path=[]) => {
                    if (typeof obj === 'string') return;
                    Object.entries(obj).forEach(([k,v])=>{
                        if (typeof v === 'string') return;
                        if (Object.values(v).every(x=>typeof x==='string')){
                            // leaf semantic set
                            lines.push(`$${themeName}-${esc([...path,k,'base'].join('-'))}: ${v.base};`);
                            lines.push(`$${themeName}-${esc([...path,k,'hover'].join('-'))}: ${v.hover};`);
                            lines.push(`$${themeName}-${esc([...path,k,'active'].join('-'))}: ${v.active};`);
                            lines.push(`$${themeName}-${esc([...path,k,'border'].join('-'))}: ${v.border};`);
                            lines.push(`$${themeName}-${esc([...path,k,'text'].join('-'))}: ${v.text};`);
                        } else {
                            build(themeName, v, [...path,k]);
                        }
                    });
                };
                build('light', t.light);
                build('dark', t.dark);
                return lines.join('\n');
            };

            const tokensToTailwind = (t) => {
                const colors = {
                    primary: { DEFAULT: t.light.colors.primary.base, hover: t.light.colors.primary.hover, active: t.light.colors.primary.active, text: t.light.colors.primary.text },
                    secondary: { DEFAULT: t.light.colors.secondary.base, hover: t.light.colors.secondary.hover, active: t.light.colors.secondary.active, text: t.light.colors.secondary.text },
                    accent: { DEFAULT: t.light.colors.accent.base, hover: t.light.colors.accent.hover, active: t.light.colors.accent.active, text: t.light.colors.accent.text },
                    success: { DEFAULT: t.light.colors.success.base },
                    warning: { DEFAULT: t.light.colors.warning.base },
                    danger: { DEFAULT: t.light.colors.danger.base },
                    info: { DEFAULT: t.light.colors.info.base },
                    neutral: { DEFAULT: t.light.colors.neutral.base }
                };
                return JSON.stringify({ theme: { extend: { colors } } }, null, 2);
            };

            const tokensToXaml = (t) => {
                let xml = '<ResourceDictionary xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml">\n';
                const out = (prefix, obj) => {
                    Object.entries(obj).forEach(([k,v])=>{
                        if (typeof v === 'string') {
                            xml += `  <Color x:Key="${prefix}${k}">${v}</Color>\n`;
                        } else if (Object.values(v).every(x=>typeof x==='string')) {
                            Object.entries(v).forEach(([sk,sv])=> xml += `  <Color x:Key="${prefix}${k}-${sk}">${sv}</Color>\n`);
                        } else {
                            out(prefix+k+'-', v);
                        }
                    });
                };
                out('Light-', t.light); out('Dark-', t.dark);
                xml += '</ResourceDictionary>';
                return xml;
            };

            // Extraction d'image (simple dominante)
            const handleImageUpload = (e) => {
                const file = e.target.files?.[0]; if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev)=>{
                    const img = new Image(); img.onload = ()=>{
                        const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                        canvas.width = img.width; canvas.height = img.height; ctx.drawImage(img,0,0);
                        const data = ctx.getImageData(0,0,canvas.width,canvas.height).data;
                        const map = {}; for (let i=0;i<data.length;i+=4){
                            const r=data[i], g=data[i+1], b=data[i+2];
                            const hex = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
                            map[hex] = (map[hex]||0)+1;
                        }
                        const top = Object.entries(map).sort((a,b)=>b[1]-a[1])[0]?.[0];
                        if (top) setBaseColor(top);
                    }; img.src = ev.target.result;
                };
                reader.readAsDataURL(file);
            };

            // UI helpers
            const ThemeBadge = ({label}) => <span className="chip bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-100">{label}</span>;

            const TokenRow = ({ theme, path, label }) => {
                const value = getPath(tokens[theme], path);
                const locked = locks.has(`${theme}|${path}`);
                return (
                    <div className="flex items-center gap-3 py-1">
                        <div className="w-40 text-sm text-gray-600 dark:text-gray-300">{label}</div>
                        <input type="color" value={value} onChange={e=>updateToken(theme, path, e.target.value)} className="w-10 h-10 rounded border" />
                        <input type="text" value={value} onChange={e=>updateToken(theme, path, e.target.value)} className="px-2 py-1 rounded border bg-white dark:bg-gray-800 w-40" />
                        <button onClick={()=>toggleLock(theme, path)} className={`px-2 py-1 rounded text-xs ${locked?'bg-amber-200 text-amber-900':'bg-gray-100 dark:bg-gray-700'}`}>{locked?'🔒 Verrouillé':'🔓 Verrouiller'}</button>
                        <div className="flex items-center gap-2 ml-auto">
                            <span className="text-xs text-gray-500">Contraste vs texte: {Color.contrastRatio(value, tokens[theme].text.primary).toFixed(2)}:1</span>
                        </div>
                    </div>
                );
            };

            const SemanticGroup = ({ theme, name, title }) => {
                const basePath = `colors.${name}`;
                const previewBg = getPath(tokens[theme], `${basePath}.base`);
                const previewText = getPath(tokens[theme], `${basePath}.text`);
                return (
                    <div className="border rounded-lg p-4">
                        <div className="flex items-center justify-between mb-3">
                            <div className="font-medium">{title}</div>
                            <div className="rounded px-3 py-1 text-sm" style={{backgroundColor: previewBg, color: previewText}}>Aperçu</div>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                            <TokenRow theme={theme} path={`${basePath}.base`} label="Base" />
                            <TokenRow theme={theme} path={`${basePath}.hover`} label="Hover" />
                            <TokenRow theme={theme} path={`${basePath}.active`} label="Active" />
                            <TokenRow theme={theme} path={`${basePath}.border`} label="Border" />
                            <TokenRow theme={theme} path={`${basePath}.text`} label="Text" />
                        </div>
                    </div>
                );
            };

            // --------------------------- Rendu ---------------------------
            return (
                <div className="min-h-screen">
                    {/* Header */}
                    <header className="bg-[var(--color-surface)] border-b border-[var(--color-border)] smooth">
                        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                            <div className="flex justify-between items-center h-16">
                                <div className="flex items-center gap-4">
                                    <h1 className="text-xl font-bold" style={{color:'var(--color-primary)'}}>Crimson</h1>
                                    <span className="text-sm text-[var(--color-text-muted)]">Générateur de palettes & tokens</span>
                                </div>
                                <div className="flex items-center gap-3">
                                    <select value={mode} onChange={e=>setMode(e.target.value)} className="px-2 py-1 rounded border bg-white dark:bg-gray-800">
                                        <option value="complementary">Complémentaire</option>
                                        <option value="analogous">Analogue</option>
                                        <option value="triadic">Triadique</option>
                                        <option value="monochrome">Monochrome</option>
                                    </select>
                                    <input type="color" value={baseColor} onChange={e=>setBaseColor(e.target.value)} className="w-9 h-9 rounded border" />
                                    <button onClick={regenerate} className="px-3 py-1 rounded bg-[var(--color-primary)] text-[var(--color-primary-text)] hover:bg-[var(--color-primary-hover)]">Régénérer</button>
                                    <button onClick={()=>setDarkMode(v=>!v)} className="px-2 py-1 rounded border border-[var(--color-border)]">{darkMode?'☀️':'🌙'}</button>
                                </div>
                            </div>
                        </div>
                    </header>

                    {/* Tabs */}
                    <nav className="bg-[var(--color-surface)] border-b border-[var(--color-border)]">
                        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
                            <div className="flex gap-6">
                                {[{id:'generator',name:'Générateur',icon:'🎨'},{id:'tokens',name:'Tokens',icon:'🏷️'},{id:'export',name:'Export',icon:'📤'},{id:'preview',name:'Aperçu',icon:'👁️'},{id:'extractor',name:'Extraction',icon:'🖼️'}].map(t=> (
                                    <button key={t.id} onClick={()=>setActiveTab(t.id)} className={`py-3 border-b-2 text-sm ${activeTab===t.id? 'border-[var(--color-primary)] text-[var(--color-primary)]':'border-transparent text-[var(--color-text-muted)] hover:text-[var(--color-text)]'}`}>
                                        <span className="mr-2">{t.icon}</span>{t.name}
                                    </button>
                                ))}
                            </div>
                        </div>
                    </nav>

                    <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                        {activeTab==='generator' && (
                            <div className="grid gap-6">
                                <div className="bg-[var(--color-surface)] border border-[var(--color-border)] rounded-lg p-6">
                                    <h2 className="text-lg font-semibold mb-4">Configuration de génération</h2>
                                    <div className="flex flex-wrap items-center gap-4">
                                        <div>
                                            <div className="text-sm mb-1">Couleur de base</div>
                                            <div className="flex items-center gap-2">
                                                <input type="color" value={baseColor} onChange={e=>setBaseColor(e.target.value)} className="w-12 h-12 rounded border" />
                                                <input type="text" value={baseColor} onChange={e=>setBaseColor(e.target.value)} className="px-2 py-2 rounded border bg-white dark:bg-gray-800 w-36" />
                                            </div>
                                        </div>
                                        <div>
                                            <div className="text-sm mb-1">Harmonisation</div>
                                            <select value={mode} onChange={e=>setMode(e.target.value)} className="px-3 py-2 rounded border bg-white dark:bg-gray-800">
                                                <option value="complementary">Complémentaire</option>
                                                <option value="analogous">Analogue</option>
                                                <option value="triadic">Triadique</option>
                                                <option value="monochrome">Monochrome</option>
                                            </select>
                                        </div>
                                        <div className="ml-auto flex gap-2">
                                            <button onClick={regenerate} className="px-4 py-2 rounded bg-[var(--color-primary)] text-[var(--color-primary-text)] hover:bg-[var(--color-primary-hover)]">Régénérer</button>
                                        </div>
                                    </div>
                                    <p className="text-sm text-[var(--color-text-muted)] mt-4">Les couleurs secondaires, d’accent et neutre sont générées selon le mode choisi. Modifiez ensuite vos tokens précisément dans l’onglet “Tokens”.</p>
                                </div>

                                <div className="grid md:grid-cols-3 gap-4">
                                    {['primary','secondary','accent'].map(k=>{
                                        const c = tokens.light.colors[k].base;
                                        const t = tokens.light.colors[k].text;
                                        return (
                                            <div key={k} className="rounded-lg p-4 border border-[var(--color-border)]" style={{backgroundColor:c, color:t}}>
                                                <div className="font-medium capitalize">{k}</div>
                                                <div className="text-xs opacity-80 mt-1">{c}</div>
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        )}

                        {activeTab==='tokens' && (
                            <div className="grid gap-6">
                                <div className="flex items-center gap-3">
                                    <div className="text-sm">Thème édité:</div>
                                    <div className="flex gap-2">
                                        <button onClick={()=>setEditingTheme('light')} className={`px-3 py-1 rounded border ${editingTheme==='light'?'border-[var(--color-primary)] text-[var(--color-primary)]':'border-[var(--color-border)]'}`}>Light</button>
                                        <button onClick={()=>setEditingTheme('dark')} className={`px-3 py-1 rounded border ${editingTheme==='dark'?'border-[var(--color-primary)] text-[var(--color-primary)]':'border-[var(--color-border)]'}`}>Dark</button>
                                    </div>
                                </div>

                                {/* Surfaces & Textes */}
                                <div className="bg-[var(--color-surface)] border border-[var(--color-border)] rounded-lg p-6">
                                    <h3 className="font-semibold mb-4">Surfaces & Texte <ThemeBadge label={editingTheme} /></h3>
                                    <div className="grid grid-cols-1 md:grid-cols-2 gap-2">
                                        <TokenRow theme={editingTheme} path="background" label="Background" />
                                        <TokenRow theme={editingTheme} path="surface" label="Surface" />
                                        <TokenRow theme={editingTheme} path="border" label="Border" />
                                        <TokenRow theme={editingTheme} path="overlay" label="Overlay" />
                                        <TokenRow theme={editingTheme} path="focus" label="Focus" />
                                        <TokenRow theme={editingTheme} path="text.primary" label="Text/Primary" />
                                        <TokenRow theme={editingTheme} path="text.secondary" label="Text/Secondary" />
                                        <TokenRow theme={editingTheme} path="text.inverse" label="Text/Inverse" />
                                    </div>
                                </div>

                                {/* Couleurs sémantiques */}
                                <div className="grid grid-cols-1 gap-6">
                                    <h3 className="font-semibold">Couleurs sémantiques</h3>
                                    <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
                                        {[
                                            ['primary','Primaire'],
                                            ['secondary','Secondaire'],
                                            ['accent','Accent'],
                                            ['success','Succès'],
                                            ['warning','Avertissement'],
                                            ['danger','Danger'],
                                            ['info','Info'],
                                            ['neutral','Neutre']
                                        ].map(([key,label])=> (
                                            <SemanticGroup key={key} theme={editingTheme} name={key} title={label} />
                                        ))}
                                    </div>
                                </div>
                            </div>
                        )}

                        {activeTab==='export' && (
                            <div className="bg-[var(--color-surface)] border border-[var(--color-border)] rounded-lg p-6">
                                <h2 className="text-lg font-semibold mb-6">Exporter les tokens</h2>
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                                    {[
                                        { format:'css', name:'CSS Variables', desc:'Variables CSS (light & dark)' },
                                        { format:'scss', name:'SCSS', desc:'Variables SCSS par token' },
                                        { format:'json', name:'JSON', desc:'Tokens (light/dark)' },
                                        { format:'tailwind', name:'Tailwind', desc:'colors extend (light)' },
                                        { format:'xaml', name:'XAML', desc:'ResourceDictionary par token' }
                                    ].map(it=> (
                                        <button key={it.format} onClick={()=>doExport(it.format)} className="p-4 rounded border border-[var(--color-border)] text-left hover:bg-[var(--color-bg)]">
                                            <div className="font-medium">{it.name}</div>
                                            <div className="text-sm text-[var(--color-text-muted)]">{it.desc}</div>
                                        </button>
                                    ))}
                                </div>
                            </div>
                        )}

                        {activeTab==='preview' && (
                            <div className="grid gap-6">
                                <div className="bg-[var(--color-surface)] border border-[var(--color-border)] rounded-lg p-6">
                                    <h2 className="text-lg font-semibold mb-4">Aperçu des composants</h2>
                                    <div className="space-y-6">
                                        <div>
                                            <h3 className="font-medium mb-2">Boutons</h3>
                                            <div className="flex flex-wrap gap-3">
                                                <button className="px-4 py-2 rounded font-medium" style={{background:'var(--color-primary)', color:'var(--color-primary-text)'}}>Primaire</button>
                                                <button className="px-4 py-2 rounded font-medium border" style={{borderColor:'var(--color-primary)', color:'var(--color-primary)'}}>Secondaire</button>
                                                <button className="px-4 py-2 rounded font-medium" style={{background:'var(--color-accent)', color:'var(--color-accent-text)'}}>Accent</button>
                                                <button className="px-4 py-2 rounded font-medium" style={{background:'var(--color-danger)', color:'var(--color-danger-text)'}}>Danger</button>
                                                <button className="px-4 py-2 rounded font-medium" style={{background:'var(--color-success)', color:'var(--color-success-text)'}}>Succès</button>
                                            </div>
                                        </div>
                                        <div>
                                            <h3 className="font-medium mb-2">Cartes</h3>
                                            <div className="grid md:grid-cols-3 gap-3">
                                                <div className="rounded border p-4" style={{background:'var(--color-surface)', borderColor:'var(--color-border)'}}>
                                                    <div className="font-medium mb-1">Carte standard</div>
                                                    <div className="text-[var(--color-text-muted)]">Texte descriptif avec contraste adapté.</div>
                                                </div>
                                                <div className="rounded p-4" style={{background:'var(--color-primary)', color:'var(--color-primary-text)'}}>
                                                    <div className="font-medium mb-1">Carte primaire</div>
                                                    <div className="opacity-90">Surface colorée selon tokens.</div>
                                                </div>
                                                <div className="rounded border-2 p-4" style={{borderColor:'var(--color-accent)'}}>
                                                    <div className="font-medium mb-1">Carte accent</div>
                                                    <div className="text-[var(--color-text-muted)]">Bordure accentuée.</div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                {/* Vérification contraste rapide */}
                                <div className="bg-[var(--color-surface)] border border-[var(--color-border)] rounded-lg p-6">
                                    <h2 className="text-lg font-semibold mb-4">Contraste clé</h2>
                                    <div className="grid md:grid-cols-2 gap-3 text-sm">
                                        {['primary','secondary','accent','danger','success','warning','info','neutral'].map(k=>{
                                            const l = Color.contrastRatio(tokens.light.colors[k].base, tokens.light.colors[k].text).toFixed(2);
                                            const d = Color.contrastRatio(tokens.dark.colors[k].base, tokens.dark.colors[k].text).toFixed(2);
                                            return (
                                                <div key={k} className="flex items-center justify-between border rounded p-3 border-[var(--color-border)]">
                                                    <div className="capitalize">{k}</div>
                                                    <div className="flex items-center gap-3">
                                                        <span className="chip bg-gray-100">Light: {l}:1</span>
                                                        <span className="chip bg-gray-100">Dark: {d}:1</span>
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                        )}

                        {activeTab==='extractor' && (
                            <div className="bg-[var(--color-surface)] border border-[var(--color-border)] rounded-lg p-6">
                                <h2 className="text-lg font-semibold mb-4">Extraction de couleurs depuis image</h2>
                                <div className="border-2 border-dashed rounded p-8 text-center">
                                    <input ref={fileInputRef} type="file" accept="image/*" onChange={handleImageUpload} className="hidden" />
                                    <button onClick={()=>fileInputRef.current?.click()} className="px-4 py-2 rounded bg-[var(--color-primary)] text-[var(--color-primary-text)]">Choisir une image</button>
                                    <p className="text-[var(--color-text-muted)] mt-2">Formats supportés : JPG, PNG, GIF</p>
                                </div>
                            </div>
                        )}
                    </main>
                </div>
            );
        }

        ReactDOM.render(<CrimsonApp />, document.getElementById('root'));
    </script>
</body>
</html>